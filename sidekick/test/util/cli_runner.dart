import 'dart:async';

import 'package:dcli/dcli.dart';
import 'package:sidekick_core/sidekick_core.dart';
import 'package:sidekick_test/sidekick_test.dart';
import 'package:test/test.dart';
import 'package:test_process/test_process.dart';

/// Deletes cached versions of the sidekick executable and sidekick CLI
void tearDownSidekickCache() {
  if (_cachedSidekickExecutableDir?.existsSync() ?? false) {
    _cachedSidekickExecutableDir!.deleteSync(recursive: true);
  }
  if (_cachedSidekickCliDir?.existsSync() ?? false) {
    _cachedSidekickCliDir!.deleteSync(recursive: true);
  }
}

/// Executes [callback] with copy of cached sidekick CLI to speed up CI tests
///
/// sidekick_core dependency is linked to the local version
R withSidekickCli<R>(R Function(SidekickCli cli) callback) {
  final copy = Directory.systemTemp.createTempSync();
  addTearDown(() => copy.deleteSync(recursive: true));
  waitForEx(_cachedSidekickCli.root.copyRecursively(copy));

  overrideSidekickCoreWithLocalPath(copy.directory('packages/dashi_sidekick'));

  final cli = SidekickCli._(copy, 'dashi');
  return callback(cli);
}

/// Cached sidekick CLI. Don't use directly, use [withSidekickCli] instead.
final _cachedSidekickCli = waitForEx(() async {
  _cachedSidekickCliDir = Directory.systemTemp.createTempSync();
  final process = await cachedSidekickExecutable.run(
    ['init', '-n', 'dashi'],
    workingDirectory: _cachedSidekickCliDir!,
  );
  if (await process.exitCode != 0) {
    process.stdoutStream().listen(print);
    process.stderrStream().listen(print);
  }
  await process.shouldExit(0);
  return SidekickCli._(_cachedSidekickCliDir!, 'dashi');
}());

Directory? _cachedSidekickCliDir;

/// Cached sidekick executable to speed up tests on CI
final cachedSidekickExecutable =
    waitForEx<SidekickExecutable>(_buildSidekickExecutable());

Directory? _cachedSidekickExecutableDir;

/// Creates the sidekick executable in a separate temp directory with linked
/// dependencies to the local sidekick_core
Future<SidekickExecutable> _buildSidekickExecutable() async {
  final original = Directory('.');
  final copy = Directory.systemTemp.createTempSync();
  _cachedSidekickExecutableDir = copy;
  await original.copyRecursively(copy);

  overrideSidekickCoreWithLocalPath(copy);

  // remove local dependency on sidekick_test, it breaks because of the
  // relative path but can be safely removed because it's just a dev_dependency
  systemDart(['pub', 'remove', 'sidekick_test'], workingDirectory: copy);

  final lockFile = copy.file('pubspec.lock');
  if (lockFile.existsSync()) {
    lockFile.deleteSync();
  }
  final dartToolDir = copy.directory('.dart_tool');
  if (dartToolDir.existsSync()) {
    dartToolDir.deleteSync(recursive: true);
  }

  startFromArgs('dart', ['pub', 'get'], workingDirectory: copy.path);
  print('created sidekick cli in ${copy.path}');

  return SidekickExecutable._(copy);
}

/// Copy of package:sidekick in temp directory.
///
/// Might contain changes compared to code in <repo>/sidekick for testing like
/// local path dependencies
class SidekickExecutable {
  final Directory root;

  SidekickExecutable._(this.root);

  Future<TestProcess> run(
    List<String> args, {
    required Directory workingDirectory,
  }) async {
    return TestProcess.start(
      'dart',
      [root.file('bin/sidekick.dart').path, ...args],
      workingDirectory: workingDirectory.path,
    );
  }
}

/// CLI generated by [SidekickExecutable]
class SidekickCli {
  final Directory root;
  final String name;

  late final File _entrypoint = root.file(name);

  SidekickCli._(this.root, this.name);

  /// Runs the CLI's entrypoint and verifies that it exits with exit code 0
  Future<void> run(
    List<String> args, {
    Directory? workingDirectory,
  }) async {
    final process = await TestProcess.start(
      _entrypoint.path,
      args,
      workingDirectory: workingDirectory?.path ?? root.path,
    );

    if (await process.exitCode != 0) {
      process.stdoutStream().listen(print);
      process.stderrStream().listen(print);
    }
    await process.shouldExit(0);
  }
}
