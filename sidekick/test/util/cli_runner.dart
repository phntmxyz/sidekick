import 'dart:async';

import 'package:dcli/dcli.dart';
import 'package:sidekick_core/sidekick_core.dart';
import 'package:sidekick_test/sidekick_test.dart';
import 'package:test/test.dart';
import 'package:test_process/test_process.dart';

/// Deletes cached sidekick CLIs
void tearDownSidekickCache() {
  if (_cachedGlobalSidekickCliDir?.existsSync() ?? false) {
    _cachedGlobalSidekickCliDir!.deleteSync(recursive: true);
  }
  if (_cachedSidekickCliDir?.existsSync() ?? false) {
    _cachedSidekickCliDir!.deleteSync(recursive: true);
  }
}

/// Executes [callback] with copy of cached sidekick CLI to speed up CI tests
///
/// sidekick_core dependency is linked to the local version
R withSidekickCli<R>(R Function(SidekickCli cli) callback) {
  final copy = Directory.systemTemp.createTempSync();
  addTearDown(() => copy.deleteSync(recursive: true));
  waitForEx(_cachedSidekickCli.root.copyRecursively(copy));

  final cli = SidekickCli._(copy, 'dashi');
  return callback(cli);
}

/// Cached sidekick CLI. Don't use directly, use [withSidekickCli] instead.
final _cachedSidekickCli = waitForEx(() async {
  _cachedSidekickCliDir = Directory.systemTemp.createTempSync();
  final process = await cachedGlobalSidekickCli.run(
    ['init', '-n', 'dashi'],
    workingDirectory: _cachedSidekickCliDir!,
  );
  if (await process.exitCode != 0) {
    process.stdoutStream().listen(print);
    process.stderrStream().listen(print);
  }
  await process.shouldExit(0);

  final cli = SidekickCli._(_cachedSidekickCliDir!, 'dashi');
  overrideSidekickCoreWithLocalPath(
    cli.root.directory('packages/dashi_sidekick'),
  );

  // run the entrypoint to kick off compilation
  // this way each copy won't have to compile again
  await cli.run([]);

  return cli;
}());

Directory? _cachedSidekickCliDir;

/// Cached global sidekick CLI to speed up tests on CI
final cachedGlobalSidekickCli =
    waitForEx<GlobalSidekickCli>(_buildGlobalSidekickCli());

Directory? _cachedGlobalSidekickCliDir;

/// Creates the global sidekick CLI in a separate temp directory with linked
/// dependencies to the local sidekick_core
Future<GlobalSidekickCli> _buildGlobalSidekickCli() async {
  final original = Directory('.');
  final copy = Directory.systemTemp.createTempSync();
  _cachedGlobalSidekickCliDir = copy;
  await original.copyRecursively(copy);

  overrideSidekickCoreWithLocalPath(copy);

  // remove local dependency on sidekick_test, it breaks because of the
  // relative path but can be safely removed because it's just a dev_dependency
  systemDart(
    ['pub', 'remove', 'sidekick_test', '--offline'],
    workingDirectory: copy,
  );

  final lockFile = copy.file('pubspec.lock');
  if (lockFile.existsSync()) {
    lockFile.deleteSync();
  }
  final dartToolDir = copy.directory('.dart_tool');
  if (dartToolDir.existsSync()) {
    dartToolDir.deleteSync(recursive: true);
  }

  final executable = copy.file('exe/global_sidekick_cli')
    ..createSync(recursive: true);
  startFromArgs('dart', ['pub', 'get'], workingDirectory: copy.path);
  startFromArgs(
    'dart',
    ['compile', 'exe', '-o', executable.path, 'bin/sidekick.dart'],
    workingDirectory: copy.path,
  );

  print('created sidekick cli in ${copy.path}');

  return GlobalSidekickCli._(copy, executable);
}

/// Copy of package:sidekick in temp directory.
///
/// Might contain changes compared to code in <repo>/sidekick for testing like
/// local path dependencies
class GlobalSidekickCli {
  final Directory root;
  final File executable;

  GlobalSidekickCli._(this.root, this.executable);

  Future<TestProcess> run(
    List<String> args, {
    required Directory workingDirectory,
  }) async {
    return TestProcess.start(
      executable.path,
      args,
      workingDirectory: workingDirectory.path,
    );
  }
}

/// CLI generated by [GlobalSidekickCli]
class SidekickCli {
  final Directory root;
  final String name;

  late final File _entrypoint = root.file(name);

  SidekickCli._(this.root, this.name);

  /// Runs the CLI's entrypoint and verifies that it exits with exit code 0
  Future<void> run(
    List<String> args, {
    Directory? workingDirectory,
  }) async {
    final process = await TestProcess.start(
      _entrypoint.path,
      args,
      workingDirectory: workingDirectory?.path ?? root.path,
    );

    if (await process.exitCode != 0) {
      process.stdoutStream().listen(print);
      process.stderrStream().listen(print);
    }
    await process.shouldExit(0);
  }
}
