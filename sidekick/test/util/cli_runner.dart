import 'dart:async';

import 'package:dcli/dcli.dart';
import 'package:sidekick_core/sidekick_core.dart';
import 'package:sidekick_test/sidekick_test.dart';
import 'package:test/test.dart';
import 'package:test_process/test_process.dart';

/// Deletes cached sidekick CLIs
void tearDownSidekickCache() {
  if (_cachedGlobalSidekickCliDir?.existsSync() ?? false) {
    _cachedGlobalSidekickCliDir!.deleteSync(recursive: true);
  }
  if (_cachedSidekickCliDir?.existsSync() ?? false) {
    _cachedSidekickCliDir!.deleteSync(recursive: true);
  }
}

/// Executes [callback] with copy of cached sidekick CLI to speed up CI tests
///
/// sidekick_core dependency is linked to the local version
Future<R> withSidekickCli<R>(
  Future<R> Function(SidekickCli cli) callback,
) async {
  final copy = Directory.systemTemp.createTempSync('sidekick_cli_');
  addTearDown(() => copy.deleteSync(recursive: true));
  await (await _cachedSidekickCli).root.copyRecursively(copy);

  final pubspecOverrides = copy.file('pubspec_overrides.yaml');
  if (pubspecOverrides.existsSync()) {
    pubspecOverrides.deleteSync();
  }

  final cli = SidekickCli._(copy, 'dashi');
  return callback(cli);
}

/// Cached sidekick CLI. Don't use directly, use [withSidekickCli] instead.
final _cachedSidekickCli = () async {
  _cachedSidekickCliDir =
      Directory.systemTemp.createTempSync('cached_sidekick_cli_');

  final process = await (await cachedGlobalSidekickCli).run(
    ['init', '-n', 'dashi'],
    workingDirectory: _cachedSidekickCliDir!,
  );

  final debug = envs['SIDEKICK_DEBUG'] == "true";
  print('Running sidekick CLI in debug mode: $debug');
  if (debug) {
    process.stdoutStream().listen(print);
    process.stderrStream().listen(print);
  }
  if (await process.exitCode != 0) {
    if (!debug) {
      process.stdoutStream().listen(print);
      process.stderrStream().listen(print);
    }
  }
  await process.shouldExit(0);

  final cli = SidekickCli._(_cachedSidekickCliDir!, 'dashi');
  overrideSidekickCoreWithLocalPath(
    cli.root.directory('dashi_sidekick'),
  );

  // run the entrypoint to kick off compilation
  // this way each copy won't have to compile again
  await cli.run([]);

  return cli;
}();

Directory? _cachedSidekickCliDir;

/// Cached global sidekick CLI to speed up tests on CI
final Future<GlobalSidekickCli> cachedGlobalSidekickCli =
    _buildGlobalSidekickCli();

Directory? _cachedGlobalSidekickCliDir;

/// Creates the global sidekick CLI in a separate temp directory with linked
/// dependencies to the local sidekick_core
Future<GlobalSidekickCli> _buildGlobalSidekickCli() async {
  final original = Directory('.');
  final copy = Directory.systemTemp.createTempSync('global_sidekick_cli_');
  _cachedGlobalSidekickCliDir = copy;
  await original.copyRecursively(copy);

  overrideSidekickCoreWithLocalPath(copy);

  final pubspecOverrides = copy.file('pubspec_overrides.yaml');
  if (pubspecOverrides.existsSync()) {
    pubspecOverrides.deleteSync();
  }

  // remove local dependency on sidekick_test, it breaks because of the
  // relative path but can be safely removed because it's just a dev_dependency
  await systemDart(
    ['pub', 'remove', 'sidekick_test'],
    workingDirectory: copy,
  );

  final lockFile = copy.file('pubspec.lock');
  if (lockFile.existsSync()) {
    lockFile.deleteSync();
  }
  final dartToolDir = copy.directory('.dart_tool');
  if (dartToolDir.existsSync()) {
    dartToolDir.deleteSync(recursive: true);
  }

  final executable = copy.file('exe/global_sidekick_cli')
    ..createSync(recursive: true);
  startFromArgs('dart', ['pub', 'get'], workingDirectory: copy.path);
  startFromArgs(
    'dart',
    ['compile', 'exe', '-o', executable.path, 'bin/sidekick.dart'],
    workingDirectory: copy.path,
  );

  print('created sidekick cli in ${copy.path}');

  return GlobalSidekickCli._(copy, executable);
}

/// Copy of package:sidekick in temp directory.
///
/// Might contain changes compared to code in `<repo>`/sidekick for testing like
/// local path dependencies
class GlobalSidekickCli {
  final Directory root;
  final File executable;

  GlobalSidekickCli._(this.root, this.executable);

  Future<TestProcess> run(
    List<String> args, {
    required Directory workingDirectory,
    Map<String, String>? environment,
  }) async {
    return await TestProcess.start(
      executable.path,
      args,
      workingDirectory: workingDirectory.path,
      environment: environment,
    );
  }
}

/// CLI generated by [GlobalSidekickCli]
class SidekickCli {
  final Directory root;
  final String name;

  late final File _entrypoint = root.file(name);

  SidekickCli._(this.root, this.name);

  /// Runs the CLI's entrypoint and verifies that it exits with exit code 0
  /// Uses POSIX shell for sh compatibility testing
  Future<TestProcess> run(
    List<String> args, {
    Directory? workingDirectory,
    Map<String, String>? environment,
  }) async {
    // Use system POSIX shell for sh compatibility testing
    final shell = Platform.isWindows ? 'sh' : '/bin/sh';

    final process = await TestProcess.start(
      shell,
      [_entrypoint.path, ...args],
      workingDirectory: workingDirectory?.path ?? root.path,
      environment: environment,
    );

    final debug = envs['SIDEKICK_DEBUG'] == "true";
    print('Running sidekick CLI in debug mode: $debug');
    if (debug) {
      process.stdoutStream().listen(print);
      process.stderrStream().listen(print);
    }
    if (await process.exitCode != 0) {
      if (!debug) {
        process.stdoutStream().listen(print);
        process.stderrStream().listen(print);
      }
    }
    await process.shouldExit(0);
    return process;
  }
}
